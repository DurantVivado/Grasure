package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/klauspost/reedsolomon"
	"golang.org/x/sync/errgroup"
)

//read the disk paths from diskFilePath
//There should be One disk path at each line
func (e *Erasure) readDiskPath() error {
	f, err := os.Open(e.diskFilePath)
	if err != nil {
		return err
	}
	defer f.Close()
	buf := bufio.NewReader(f)

	for {
		line, _, err := buf.ReadLine()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}
		diskInfo := &DiskInfo{diskPath: string(line), available: true}
		e.diskInfos = append(e.diskInfos, diskInfo)
	}
	return nil
}

//initiate the erasure-coded system
func (e *Erasure) initHDR() {
	fmt.Println("Warning: you are intializing a new erasure-coded system, which means the previous data will also be reset.")
	if ans, err := consultUserBeforeAction(); !ans {
		return
	} else if err != nil {
		failOnErr(mode, err)
	}
	e.k = k
	e.m = m
	if e.k <= 0 || e.m <= 0 {
		failOnErr(mode, reedsolomon.ErrInvShardNum)
	}
	//The reedsolomon library only implements GF(2^8) and will be improved later
	if e.k+e.m > 256 {
		failOnErr(mode, reedsolomon.ErrMaxShardNum)
	}
	e.blockSize = blockSize
	err = e.readDiskPath()
	failOnErr(mode, err)
	if e.k+e.m > len(e.diskInfos) {
		failOnErr(mode, ErrTooFewDisks)
	}
	//we persit meta info info in hard drives
	err = e.writeConfig()
	failOnErr(mode, err)
	//delete the data blocks under all diskPath
	err = e.reset()
	failOnErr(mode, err)
	fmt.Println("System init!")
}

//read the config info in config file
//Every time read file list in system warm-up
func (e *Erasure) readConfig() error {
	if ex, err := PathExist(e.configFile); !ex && err == nil {
		return ErrConfFileNotExist
	} else if err != nil {
		return err
	}
	f, err := os.Open(e.configFile)
	if err != nil {
		return err
	}
	defer f.Close()

	buf := bufio.NewReader(f)
	//recurrently read lines
	_, _, err = buf.ReadLine() //dismiss the first line
	if err != nil {
		return ErrNotInitialized
	}
	line, _, err := buf.ReadLine()
	if err != nil {
		return ErrNotInitialized
	}
	split := strings.Split(string(line), " ")
	k, err := strconv.ParseInt(split[0], 10, 32)
	if err != nil {
		return ErrNotInitialized
	}
	m, err := strconv.ParseInt(split[1], 10, 32)
	if err != nil {
		return ErrNotInitialized
	}
	line, _, err = buf.ReadLine()
	if err != nil {
		return ErrNotInitialized
	}
	bs, err := strconv.ParseInt(string(line), 10, 32)
	if err != nil {
		return ErrNotInitialized
	}
	e.k = int(k)
	e.m = int(m)
	e.blockSize = bs
	e.conStripes = conStripes
	//initialize the ReedSolomon Code
	e.enc, err = reedsolomon.New(e.k, e.m)
	e.dataStripeSize = int64(e.k) * blockSize
	e.allStripeSize = int64(e.k+e.m) * blockSize

	e.errgroupPool.New = func() interface{} {
		return &errgroup.Group{}
	}

	//e.sEnc, err = reedsolomon.NewStreamC(e.k, e.m, conReads, conWrites)
	if err != nil {
		return err
	}
	//next is the file lists //read all file meta
	var str string
	for {
		//read the file name
		if len(str) == 0 {
			//if str is not empty, we retain previous file name
			str, err = buf.ReadString('\n')

		}
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}
		fi := &FileInfo{}
		fi.fileName = strings.TrimSuffix(str, "\n")
		//read the file size
		str, err = buf.ReadString('\n')
		if err == io.EOF {
			return fmt.Errorf("%s 's meta data fileSize is incompleted, please check", fi.fileName)
		} else if err != nil {
			return err
		}
		fi.fileSize, _ = strconv.ParseInt(strings.TrimSuffix(str, "\n"), 10, 64)
		//read file hash
		str, err = buf.ReadString('\n')
		if err == io.EOF {
			return fmt.Errorf("%s 's meta data hash is incompleted, please check", fi.fileName)
		} else if err != nil {
			return err
		}
		fi.hash = strings.TrimSuffix(str, "\n")

		//read the block distribution
		for {
			str, err = buf.ReadString('\n')
			if len(str) == 0 || str[0] != '[' {
				break
			}
			str = strings.Trim(str, "[]\n")

			var stripeDist []int
			for _, s := range strings.Split(str, " ") {
				num, err := strconv.Atoi(s)
				if err != nil {
					return err
				}
				stripeDist = append(stripeDist, num)
			}
			fi.distribution = append(fi.distribution, stripeDist)
			if err == io.EOF {
				break
			} else if err != nil {
				return err
			}

		}
		e.fileMap[fi.fileName] = fi

	}

	return nil
}

//write the erasure parameters into config files
func (e *Erasure) writeConfig() error {

	f, err := os.OpenFile(e.configFile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0754)
	if err != nil {
		return err
	}
	defer f.Close()

	//1. k,m
	//2. rand seed
	buf := bufio.NewWriter(f)
	_, err = buf.WriteString("This file is automatically generated, DO NOT EDIT\n")
	if err != nil {
		return err
	}
	line := fmt.Sprintf("%d %d\n%d\n", e.k, e.m, e.blockSize)
	_, err = buf.WriteString(line)
	if err != nil {
		return err
	}
	//when fileMap is changed, we update the fileList
	for _, v := range e.fileMap {
		line := fmt.Sprintf("%s\n%d\n%s\n", filepath.Base(v.fileName), v.fileSize, v.hash)
		buf.WriteString(line)
		for _, v := range v.distribution {
			tmp := fmt.Sprintf("%v\n", v)
			buf.WriteString(tmp)
		}
	}
	buf.Flush()
	f.Sync()
	return nil
}

//reconstruct the config file if possible
func (e *Erasure) rebuildConfig() error {
	//we read file meta in the disk path and try to rebuild the config file
	return nil
}

//reset the storage assets
func (e *Erasure) reset() error {
	g := new(errgroup.Group)

	for _, path := range e.diskInfos {
		path := path
		files, err := os.ReadDir(path.diskPath)
		if err != nil {
			return err
		}
		if len(files) == 0 {
			continue
		}
		g.Go(func() error {
			for _, file := range files {
				err = os.RemoveAll(path.diskPath + "/" + file.Name())
				if err != nil {
					return err
				}

			}
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return err
	}
	return nil
}

//delete specific file
func (e *Erasure) removeFile(filename string) error {
	g := new(errgroup.Group)

	for _, path := range e.diskInfos {
		path := path
		files, err := os.ReadDir(path.diskPath)
		if err != nil {
			return err
		}
		if len(files) == 0 {
			continue
		}
		g.Go(func() error {
			err = os.RemoveAll(path.diskPath + "/" + filename)
			if err != nil {
				return err
			}
			return nil
		})
	}
	if err := g.Wait(); err != nil {
		return err
	}
	delete(e.fileMap, filename)
	log.Printf("file %s successfully deleted.", filename)
	return nil
}

//check file blocks integrity
func (e *Erasure) readBlocks(filename string) ([][]byte, error) {
	//we scan the file in the conf and check hash
	erg := new(errgroup.Group)
	data := make([][]byte, e.k+e.m)
	for i := range e.diskInfos {
		i := i
		//we have to make sure the dist is appended to fi.distribution in order
		erg.Go(func() error {
			folderPath := filepath.Join(e.diskInfos[i].diskPath, filename)
			if ok, err := PathExist(folderPath); !ok {
				return fmt.Errorf("error: %s doesn't exist", folderPath)
			} else if err != nil {
				return err
			}

			// We decide the part name according to whether it belongs to data or parity
			partPath := filepath.Join(folderPath, "BLOB")
			if ok, err := PathExist(partPath); !ok {
				return fmt.Errorf("error: %s doesn't exist", partPath)
			} else if err != nil {
				return err
			}

			//read the file and check the hashstr
			rf, err := os.Open(partPath)
			if err != nil {
				return err
			}
			defer rf.Close()
			buf := bufio.NewReader(rf)
			st, err := os.Stat(partPath)
			if err != nil {
				return err
			}
			part := make([]byte, st.Size())
			_, err = buf.Read(part)
			if err != nil {
				return err
			}
			data[i] = part
			// // rf.Seek(0, 0)
			// h := sha256.New()
			// if _, err := io.Copy(h, rf); err != nil {
			// 	return err
			// }
			// hashStr := fmt.Sprintf("%x", h.Sum(nil))
			// metaPath := folderPath + "/META"
			// if ok, err := PathExist(metaPath); !ok {
			// 	return fmt.Errorf("error: %s doesn't exist", partPath)
			// } else if err != nil {
			// 	return err
			// }
			// //read the file and check the hashstr
			// mf, err := os.Open(metaPath)
			// if err != nil {
			// 	return err
			// }
			// defer mf.Close()
			// buf = bufio.NewReader(mf)
			// truehash, err := buf.ReadString('\n')
			// truehash = strings.TrimSuffix(truehash, "\n")
			// if err != nil {
			// 	return nil
			// }
			// if strings.Compare(hashStr, truehash) != 0 {
			// 	return ErrFileIncompleted
			// }
			return nil
		})

	}

	if err := erg.Wait(); err != nil {
		//we do not stop when encountered with error, however we try to recover it
		log.Println(err)
	}
	return data, nil
}
