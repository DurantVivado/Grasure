
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Grasure: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/DurantVivado/Grasure/erasure-encode.go (78.0%)</option>
				
				<option value="file1">github.com/DurantVivado/Grasure/erasure-errors.go (0.0%)</option>
				
				<option value="file2">github.com/DurantVivado/Grasure/erasure-init.go (48.2%)</option>
				
				<option value="file3">github.com/DurantVivado/Grasure/erasure-layout.go (91.7%)</option>
				
				<option value="file4">github.com/DurantVivado/Grasure/erasure-read.go (54.0%)</option>
				
				<option value="file5">github.com/DurantVivado/Grasure/erasure-recover.go (0.0%)</option>
				
				<option value="file6">github.com/DurantVivado/Grasure/erasure-scaling.go (0.0%)</option>
				
				<option value="file7">github.com/DurantVivado/Grasure/erasure-simFailure.go (0.0%)</option>
				
				<option value="file8">github.com/DurantVivado/Grasure/erasure-update.go (0.0%)</option>
				
				<option value="file9">github.com/DurantVivado/Grasure/erasure-utils.go (27.5%)</option>
				
				<option value="file10">github.com/DurantVivado/Grasure/sga.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package grasure

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"

        "golang.org/x/sync/errgroup"
)

//EncodeFile takes filepath as input and encodes the file into data and parity blocks concurrently.
//
// It returns `*fileInfo` and an error. Specify `blocksize` and `conStripe` for better performance.
func (e *Erasure) EncodeFile(filename string) (*fileInfo, error) <span class="cov8" title="1">{
        baseFileName := filepath.Base(filename)
        if _, ok := e.fileMap.Load(baseFileName); ok &amp;&amp; !e.Override </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("the file %s has already been in the file system, if you wish to override, please attach `-o`",
                        baseFileName)
        }</span>
        <span class="cov8" title="1">f, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        //We sum the hash of the file
        hashStr, err := hashStr(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">f.Seek(0, 0)
        fi := &amp;fileInfo{}
        fi.Hash = hashStr
        fi.FileName = baseFileName
        fileInfo, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fileSize := fileInfo.Size()
        fi.FileSize = fileSize
        //how much data read in a batch is worth discussion
        //for blocks...

        //encode the data
        stripeNum := int(ceilFracInt64(fileSize, e.dataStripeSize))
        //we split file into stripes and randomly distribute the blocks to various disks
        //and for stripes of the same disk, we concatenate all blocks to create the sole file
        //for accelerating, we start multiple goroutines
        //The last stripe will be refilled with zeros
        of := make([]*os.File, e.DiskNum)
        //first open relevant file resources
        erg := new(errgroup.Group)
        //save the blob
        for i := range e.diskInfos[:e.DiskNum] </span><span class="cov8" title="1">{
                i := i
                //we have to make sure the dist is appended to fi.Distribution in order
                erg.Go(func() error </span><span class="cov8" title="1">{
                        folderPath := filepath.Join(e.diskInfos[i].diskPath, baseFileName)
                        //if override is specified, we override previous data
                        if e.Override </span><span class="cov8" title="1">{
                                if err := os.RemoveAll(folderPath); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">if err := os.Mkdir(folderPath, 0666); err != nil </span><span class="cov0" title="0">{
                                return errDataDirExist
                        }</span>
                        // We decide the part name according to whether it belongs to data or parity
                        <span class="cov8" title="1">partPath := filepath.Join(folderPath, "BLOB")
                        //Create the file and write in the parted data
                        of[i], err = os.OpenFile(partPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">numBlob := ceilFracInt(stripeNum, e.ConStripes)
        stripeCnt := 0
        //for every conStripe stripes, we set one goroutine
        nextStripe := 0
        //allocate the memory pool only when needed
        // e.dataBlobPool.New = func() interface{} {
        //         out := make([][]byte, e.ConStripes)
        //         for i := range out {
        //                 out[i] = make([]byte, e.dataStripeSize)
        //         }
        //         return &amp;out
        // }
        //we make layout independent of encoding and user-friendly
        //all described in erasure-layout.go

        e.generateLayout(fi)
        blobBuf := makeArr2DByte(e.ConStripes, int(e.dataStripeSize))
        for blob := 0; blob &lt; numBlob; blob++ </span><span class="cov8" title="1">{
                if stripeCnt+e.ConStripes &gt; stripeNum </span><span class="cov0" title="0">{
                        nextStripe = stripeNum - stripeCnt
                }</span> else<span class="cov8" title="1"> {
                        nextStripe = e.ConStripes
                }</span>
                <span class="cov8" title="1">eg := e.errgroupPool.Get().(*errgroup.Group)
                // blobBuf := *e.dataBlobPool.Get().(*[][]byte)
                for s := 0; s &lt; nextStripe; s++ </span><span class="cov8" title="1">{
                        s := s
                        offset := int64(stripeCnt+s) * e.dataStripeSize
                        eg.Go(func() error </span><span class="cov8" title="1">{
                                _, err := f.ReadAt(blobBuf[s], offset)
                                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                //split and encode the data
                                <span class="cov8" title="1">encodeData, err := e.encodeData(blobBuf[s])
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                //generate random distrinution for data and parity
                                <span class="cov8" title="1">randDist := fi.Distribution[stripeCnt+s]
                                // randDist := getSeqArr(e.K + e.M)

                                erg := e.errgroupPool.Get().(*errgroup.Group)
                                defer e.errgroupPool.Put(erg)
                                //save the blob
                                for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov8" title="1">{
                                        i := i
                                        diskId := randDist[i]
                                        erg.Go(func() error </span><span class="cov8" title="1">{
                                                offset := fi.blockToOffset[stripeCnt+s][i]
                                                _, err := of[diskId].WriteAt(encodeData[i], int64(offset)*e.BlockSize)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">return nil</span>
                                        })

                                }
                                <span class="cov8" title="1">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        })
                }
                <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">e.errgroupPool.Put(eg)
                // e.dataBlobPool.Put(&amp;blobBuf)
                stripeCnt += nextStripe</span>

        }
        <span class="cov8" title="1">for i := range of </span><span class="cov8" title="1">{
                of[i].Close()
        }</span>
        //record the file meta
        //transform map into array for json marshaling
        <span class="cov8" title="1">e.fileMap.Store(baseFileName, fi)
        fi.blockInfos = make([][]*blockInfo, stripeNum)
        for row := range fi.Distribution </span><span class="cov8" title="1">{
                fi.blockInfos[row] = make([]*blockInfo, e.K+e.M)
                for line := range fi.Distribution[row] </span><span class="cov8" title="1">{
                        fi.blockInfos[row][line] = &amp;blockInfo{bstat: blkOK}
                }</span>
        }
        // e.fileMap[baseFileName] = fi
        <span class="cov8" title="1">if !e.Quiet </span><span class="cov0" title="0">{
                log.Println(baseFileName, " successfully encoded. encoding size ",
                        e.stripedFileSize(fileSize), "bytes")
        }</span>
        <span class="cov8" title="1">return fi, nil</span>
}

//split and encode data
func (e *Erasure) encodeData(data []byte) ([][]byte, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return make([][]byte, e.K+e.M), nil
        }</span>
        <span class="cov8" title="1">encoded, err := e.enc.Split(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := e.enc.Encode(encoded); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return encoded, nil</span>
}

//return final erasure size from original size,
//Every block spans all the data disks and split into shards
//the shardSize is the same except for the last one
func (e *Erasure) stripedFileSize(totalLen int64) int64 <span class="cov0" title="0">{
        if totalLen &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">numStripe := ceilFracInt64(totalLen, e.dataStripeSize)
        return numStripe * e.allStripeSize</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package grasure

import (
        "errors"
        "fmt"
)

type diskError struct {
        diskPath string
        cause    string
}

func (e *diskError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("disk %s is not available for :%s", e.diskPath, e.cause)
}</span>

//Error definitions

var errConfFileNotExist = errors.New("the conf file not exist")

var errEmptyData = errors.New("the file to encode is empty")

var errDataDirExist = errors.New("data directory already exists")

var errTooFewDisksAlive = errors.New("too few survival disks, i.e., k+m &lt; N")

var errNotInitialized = errors.New("system not initialized, please initialize with `-mode init` first")

var errSurvivalNotEnoughForDecoding = errors.New("the failed block number exceeds fault tolerance, data renders unrecoverable")

var errFileIncompleted = errors.New("file hash check fails, file renders incompleted")

var errFileNotFound = errors.New("file not found")

var errFailModeNotRecognized = errors.New("the fail mode is not recognizable, please specify in \"diskFail\" or \"bitRot\"")

var errInvalidReplicateFactor = errors.New("the replicate factor MUST be non-negative")

var errNotEnoughBackupForRecovery = errors.New("not enough disk for recovery, needs more backup devices")

var errFileBlobNotFound = errors.New("file blob not found. please try to read it")

var errDiskNumTooLarge = errors.New("diskNum is larger than provided")

var errTooFewBlockAliveInStripe = errors.New("not enough blocks for reading in a stripe")

// errUnexpected - unexpected error, requires manual intervention.
var errUnexpected = storageErr("unexpected error, please report this issue at https://github.com/minio/minio/issues")

// errCorruptedFormat - corrupted backend format.
var errCorruptedFormat = storageErr("corrupted backend format, specified disk mount has unexpected previous content")

// errUnformattedDisk - unformatted disk found.
var errUnformattedDisk = storageErr("unformatted disk found")

// errInconsistentDisk - inconsistent disk found.
var errInconsistentDisk = storageErr("inconsistent disk found")

// errUnsupporteDisk - when disk does not support O_DIRECT flag.
var errUnsupportedDisk = storageErr("disk does not support O_DIRECT")

// errDiskFull - cannot create volume or files when disk is full.
var errDiskFull = storageErr("disk path full")

// errDiskNotDir - cannot use storage disk if its not a directory
var errDiskNotDir = storageErr("disk is not directory or mountpoint")

// errDiskNotFound - cannot find the underlying configured disk anymore.
var errDiskNotFound = storageErr("disk not found")

// errFaultyRemoteDisk - remote disk is faulty.
var errFaultyRemoteDisk = storageErr("remote disk is faulty")

// errFaultyDisk - disk is faulty.
var errFaultyDisk = storageErr("disk is faulty")

// errDiskAccessDenied - we don't have write permissions on disk.
var errDiskAccessDenied = storageErr("disk access denied")

// errFileNotFound - cannot find the file.

// errFileNotFound - cannot find requested file version.
var errFileVersionNotFound = storageErr("file version not found")

// errTooManyOpenFiles - too many open files.
var errTooManyOpenFiles = storageErr("too many open files, please increase 'ulimit -n'")

// errFileNameTooLong - given file name is too long than supported length.
var errFileNameTooLong = storageErr("file name too long")

// errVolumeExists - cannot create same volume again.
var errVolumeExists = storageErr("volume already exists")

// errIsNotRegular - not of regular file type.
var errIsNotRegular = storageErr("not of regular file type")

// errPathNotFound - cannot find the path.
var errPathNotFound = storageErr("path not found")

// errVolumeNotFound - cannot find the volume.
var errVolumeNotFound = storageErr("volume not found")

// errVolumeNotEmpty - volume not empty.
var errVolumeNotEmpty = storageErr("volume is not empty")

// errVolumeAccessDenied - cannot access volume, insufficient permissions.
var errVolumeAccessDenied = storageErr("volume access denied")

// errFileAccessDenied - cannot access file, insufficient permissions.
var errFileAccessDenied = storageErr("file access denied")

// errFileCorrupt - file has an unexpected size, or is not readable
var errFileCorrupt = storageErr("file is corrupted")

// errBitrotHashAlgoInvalid - the algo for bit-rot hash
// verification is empty or invalid.
var errBitrotHashAlgoInvalid = storageErr("bit-rot hash algorithm is invalid")

// errCrossDeviceLink - rename across devices not allowed.
var errCrossDeviceLink = storageErr("Rename across devices not allowed, please fix your backend configuration")

// errMinDiskSize - cannot create volume or files when disk size is less than threshold.
var errMinDiskSize = storageErr("The disk size is less than 900MiB threshold")

// errLessData - returned when less data available than what was requested.
var errLessData = storageErr("less data available than what was requested")

// errMoreData = returned when more data was sent by the caller than what it was supposed to.
var errMoreData = storageErr("more data was sent than what was advertised")

// indicates readDirFn to return without further applying the fn()
var errDoneForNow = errors.New("done for now")

// errSkipFile returned by the fn() for readDirFn() when it needs
// to proceed to next entry.
var errSkipFile = errors.New("skip this file")

// storageErr represents error generated by xlStorage call.
type storageErr string

func (h storageErr) error() string <span class="cov0" title="0">{
        return string(h)
}</span>

// Collection of basic errors.
// Is a one place function which converts all os.PathError
// into a more FS object layer friendly form, converts
// known errors into their typed form for top level
// interpretation.
// func osErrToFileErr(err error) error {
//         if err == nil {
//                 return nil
//         }
//         if osIsNotExist(err) {
//                 return errFileNotFound
//         }
//         if osIsPermission(err) {
//                 return errFileAccessDenied
//         }
//         if isSysErrNotDir(err) || isSysErrIsDir(err) {
//                 return errFileNotFound
//         }
//         if isSysErrPathNotFound(err) {
//                 return errFileNotFound
//         }
//         if isSysErrTooManyFiles(err) {
//                 return errTooManyOpenFiles
//         }
//         if isSysErrHandleInvalid(err) {
//                 return errFileNotFound
//         }
//         if isSysErrIO(err) {
//                 return errFaultyDisk
//         }
//         if isSysErrInvalidArg(err) {
//                 return errUnsupportedDisk
//         }
//         if isSysErrNoSpace(err) {
//                 return errDiskFull
//         }
//         return err
// }
</pre>
		
		<pre class="file" id="file2" style="display: none">package grasure

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"

        "github.com/DurantVivado/reedsolomon"
        "golang.org/x/sync/errgroup"
)

//ReadDiskPath reads the disk paths from diskFilePath.
//There should be exactly ONE disk path at each line.
//
//This func can NOT be called concurrently.
func (e *Erasure) ReadDiskPath() error <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        f, err := os.Open(e.DiskFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        buf := bufio.NewReader(f)
        e.diskInfos = make([]*diskInfo, 0)
        for </span><span class="cov8" title="1">{
                line, _, err := buf.ReadLine()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">path := string(line)
                if ok, err := pathExist(path); !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        return &amp;diskError{path, "disk path not exist"}
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">metaPath := filepath.Join(path, "META")
                flag := false
                if ok, err := pathExist(metaPath); ok &amp;&amp; err == nil </span><span class="cov8" title="1">{
                        flag = true
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">diskInfo := &amp;diskInfo{diskPath: string(line), available: true, ifMetaExist: flag}
                e.diskInfos = append(e.diskInfos, diskInfo)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

//Init initiates the erasure-coded system, this func can NOT be called concurrently.
// It will clear all the data on the storage, so a consulting procedure is added in advance of perilous action.
//
//Note if `assume` renders yes then the consulting part will be skipped.
func (e *Erasure) InitSystem(assume bool) error <span class="cov8" title="1">{
        if !e.Quiet </span><span class="cov0" title="0">{
                fmt.Println("Warning: you are intializing a new erasure-coded system, which means the previous data will also be reset.")
        }</span>
        <span class="cov8" title="1">if !assume </span><span class="cov0" title="0">{
                if ans, err := consultUserBeforeAction(); !ans &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if e.K &lt;= 0 || e.M &lt;= 0 </span><span class="cov0" title="0">{
                return reedsolomon.ErrInvShardNum
        }</span>
        //The reedsolomon library only implements GF(2^8) and will be improved later
        <span class="cov8" title="1">if e.K+e.M &gt; 256 </span><span class="cov0" title="0">{
                return reedsolomon.ErrMaxShardNum
        }</span>
        <span class="cov8" title="1">if e.K+e.M &gt; e.DiskNum </span><span class="cov0" title="0">{
                return errTooFewDisksAlive
        }</span>
        <span class="cov8" title="1">if e.DiskNum &gt; len(e.diskInfos) </span><span class="cov0" title="0">{
                return errDiskNumTooLarge
        }</span>
        <span class="cov8" title="1">if e.ConStripes &lt; 1 </span><span class="cov0" title="0">{
                e.ConStripes = 1 //totally serialized
        }</span>
        //replicate the config files

        <span class="cov8" title="1">if e.ReplicateFactor &lt; 1 </span><span class="cov0" title="0">{
                return errInvalidReplicateFactor
        }</span>
        <span class="cov8" title="1">err = e.resetSystem()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !e.Quiet </span><span class="cov0" title="0">{
                fmt.Printf("System init!\n Erasure parameters: dataShards:%d, parityShards:%d,blocksize:%d,diskNum:%d\n",
                        e.K, e.M, e.BlockSize, e.DiskNum)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//reset the storage assets
func (e *Erasure) reset() error <span class="cov8" title="1">{

        g := new(errgroup.Group)

        for _, path := range e.diskInfos[:e.DiskNum] </span><span class="cov8" title="1">{
                path := path
                files, err := os.ReadDir(path.diskPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(files) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        for _, file := range files </span><span class="cov8" title="1">{
                                err = os.RemoveAll(filepath.Join(path.diskPath, file.Name()))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                        }
                        <span class="cov8" title="1">return nil</span>
                })
        }
        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//reset the system including config and data
func (e *Erasure) resetSystem() error <span class="cov8" title="1">{

        //in-memory meta reset
        e.FileMeta = make([]*fileInfo, 0)
        // for k := range e.fileMap {
        //         delete(e.fileMap, k)
        // }
        e.fileMap.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                e.fileMap.Delete(key)
                return true
        }</span>)
        <span class="cov8" title="1">err = e.WriteConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //delete the data blocks under all diskPath
        <span class="cov8" title="1">err = e.reset()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = e.replicateConfig(e.ReplicateFactor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//ReadConfig reads the config file during system warm-up.
//
//Calling it before actions like encode and read is a good habit.
func (e *Erasure) ReadConfig() error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if ex, err := pathExist(e.ConfigFile); !ex &amp;&amp; err == nil </span><span class="cov0" title="0">{
                // we try to recover the config file from the storage system
                // which renders the last chance to heal
                err = e.rebuildConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return errConfFileNotExist
                }</span>
        } else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">data, err := ioutil.ReadFile(e.ConfigFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;e)
        if err != nil </span><span class="cov0" title="0">{
                //if json file is broken, we try to recover it

                err = e.rebuildConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return errConfFileNotExist
                }</span>

                <span class="cov0" title="0">data, err := ioutil.ReadFile(e.ConfigFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = json.Unmarshal(data, &amp;e)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        //initialize the ReedSolomon Code
        <span class="cov8" title="1">e.enc, err = reedsolomon.New(e.K, e.M,
                reedsolomon.WithAutoGoroutines(int(e.BlockSize)),
                reedsolomon.WithCauchyMatrix(),
                reedsolomon.WithInversionCache(true),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e.dataStripeSize = int64(e.K) * e.BlockSize
        e.allStripeSize = int64(e.K+e.M) * e.BlockSize

        e.errgroupPool.New = func() interface{} </span><span class="cov8" title="1">{
                return &amp;errgroup.Group{}
        }</span>
        //unzip the fileMap
        <span class="cov8" title="1">for _, f := range e.FileMeta </span><span class="cov0" title="0">{
                stripeNum := len(f.Distribution)
                f.blockToOffset = makeArr2DInt(stripeNum, e.K+e.M)
                f.blockInfos = make([][]*blockInfo, stripeNum)
                countSum := make([]int, e.DiskNum)
                for row := range f.Distribution </span><span class="cov0" title="0">{
                        f.blockInfos[row] = make([]*blockInfo, e.K+e.M)
                        for line := range f.Distribution[row] </span><span class="cov0" title="0">{
                                diskId := f.Distribution[row][line]
                                f.blockToOffset[row][line] = countSum[diskId]
                                f.blockInfos[row][line] = &amp;blockInfo{bstat: blkOK}
                                countSum[diskId]++
                        }</span>
                }
                //update the numBlocks
                <span class="cov0" title="0">for i := range countSum </span><span class="cov0" title="0">{
                        e.diskInfos[i].numBlocks += countSum[i]
                }</span>
                <span class="cov0" title="0">e.fileMap.Store(f.FileName, f)</span>
                // e.fileMap[f.FileName] = f

        }
        <span class="cov8" title="1">e.FileMeta = make([]*fileInfo, 0)
        // we
        //e.sEnc, err = reedsolomon.NewStreamC(e.K, e.M, conReads, conWrites)
        // if err != nil {
        //         return err
        // }

        return nil</span>
}

//Replicate the config file into the system for k-fold
//it's NOT striped and encoded as a whole piece.
func (e *Erasure) replicateConfig(k int) error <span class="cov8" title="1">{
        selectDisk := genRandomArr(e.DiskNum, 0)[:k]
        for _, i := range selectDisk </span><span class="cov8" title="1">{
                disk := e.diskInfos[i]
                disk.ifMetaExist = true
                replicaPath := filepath.Join(disk.diskPath, "META")
                _, err = copyFile(e.ConfigFile, replicaPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err.Error())
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

//WriteConfig writes the erasure parameters and file information list into config files.
//
//Calling it after actions like encode and read is a good habit.
func (e *Erasure) WriteConfig() error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        f, err := os.OpenFile(e.ConfigFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        // we marsh filemap into fileLists
        // for _, v := range e.fileMap {
        //         e.FileMeta = append(e.FileMeta, v)
        // }
        e.fileMap.Range(func(k, v interface{}) bool </span><span class="cov8" title="1">{
                e.FileMeta = append(e.FileMeta, v.(*fileInfo))
                return true
        }</span>)
        <span class="cov8" title="1">data, err := json.Marshal(e)
        // data, err := json.MarshalIndent(e, " ", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">buf := bufio.NewWriter(f)
        _, err = buf.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">buf.Flush()
        // f.Sync()
        err = e.updateConfigReplica()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//reconstruct the config file if possible
func (e *Erasure) rebuildConfig() error <span class="cov0" title="0">{
        //we read file meta in the disk path and try to rebuild the config file
        for i := range e.diskInfos[:e.DiskNum] </span><span class="cov0" title="0">{
                disk := e.diskInfos[i]
                replicaPath := filepath.Join(disk.diskPath, "META")
                if ok, err := pathExist(replicaPath); !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_, err = copyFile(replicaPath, e.ConfigFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">return nil</span>
}

//update the config file of all replica
func (e *Erasure) updateConfigReplica() error <span class="cov8" title="1">{

        //we read file meta in the disk path and try to rebuild the config file
        if e.ReplicateFactor &lt; 1 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for i := range e.diskInfos[:e.DiskNum] </span><span class="cov8" title="1">{
                disk := e.diskInfos[i]
                replicaPath := filepath.Join(disk.diskPath, "META")
                if ok, err := pathExist(replicaPath); !ok &amp;&amp; err == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">_, err = copyFile(e.ConfigFile, replicaPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

//RemoveFile deletes specific file `filename`in the system.
//
//Both the file blobs and meta data are deleted. It's currently irreversible.
func (e *Erasure) RemoveFile(filename string) error <span class="cov0" title="0">{
        baseFilename := filepath.Base(filename)
        if _, ok := e.fileMap.Load(baseFilename); !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("the file %s does not exist in the file system",
                        baseFilename)
        }</span>
        <span class="cov0" title="0">g := new(errgroup.Group)

        for _, path := range e.diskInfos[:e.DiskNum] </span><span class="cov0" title="0">{
                path := path
                files, err := os.ReadDir(path.diskPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">g.Go(func() error </span><span class="cov0" title="0">{

                        err = os.RemoveAll(filepath.Join(path.diskPath, baseFilename))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
        }
        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">e.fileMap.Delete(baseFilename)
        // delete(e.fileMap, filename)
        if !e.Quiet </span><span class="cov0" title="0">{
                log.Printf("file %s successfully deleted.", baseFilename)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//check if file exists both in config and storage blobs
func (e *Erasure) checkIfFileExist(filename string) (bool, error) <span class="cov0" title="0">{
        //1. first check the storage blobs if file still exists
        baseFilename := filepath.Base(filename)

        g := new(errgroup.Group)

        for _, path := range e.diskInfos[:e.DiskNum] </span><span class="cov0" title="0">{
                path := path
                files, err := os.ReadDir(path.diskPath)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">g.Go(func() error </span><span class="cov0" title="0">{

                        subpath := filepath.Join(path.diskPath, baseFilename)
                        if ok, err := pathExist(subpath); !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                return errFileBlobNotFound
                        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
        }
        <span class="cov0" title="0">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        //2. check if fileMap contains the file
        <span class="cov0" title="0">if _, ok := e.fileMap.Load(baseFilename); !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package grasure

//Examplar random distribution layout generator
//Two structure need specialized: fi.blockToOffset and fi.Distribution
func (e *Erasure) generateLayout(fi *fileInfo) <span class="cov8" title="1">{
        if fi == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">stripeNum := int(ceilFracInt64(fi.FileSize, e.dataStripeSize))
        fi.Distribution = make([][]int, stripeNum)
        fi.blockToOffset = makeArr2DInt(stripeNum, e.K+e.M)
        countSum := make([]int, e.DiskNum)
        for i := 0; i &lt; stripeNum; i++ </span><span class="cov8" title="1">{
                fi.Distribution[i] = genRandomArr(e.DiskNum, 0)[:e.K+e.M]
                for j := 0; j &lt; e.K+e.M; j++ </span><span class="cov8" title="1">{
                        diskId := fi.Distribution[i][j]
                        fi.blockToOffset[i][j] = countSum[diskId]
                        countSum[diskId]++
                }</span>

        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package grasure

import (
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "sync/atomic"

        "github.com/DurantVivado/reedsolomon"
        "golang.org/x/sync/errgroup"
)

//ReadFile reads ONE file  on the system and save it to local `savePath`.
//
//In case of any failure within fault tolerance, the file will be decoded first.
//`Degrade` indicates whether degraded read is enabled.
func (e *Erasure) ReadFile(filename string, savepath string, options *Options) error <span class="cov8" title="1">{
        baseFileName := filepath.Base(filename)
        intFi, ok := e.fileMap.Load(baseFileName)
        if !ok </span><span class="cov0" title="0">{
                return errFileNotFound
        }</span>
        <span class="cov8" title="1">fi := intFi.(*fileInfo)

        fileSize := fi.FileSize
        stripeNum := int(ceilFracInt64(fileSize, e.dataStripeSize))
        dist := fi.Distribution
        //first we check the number of alive disks
        // to judge if any part need reconstruction
        alive := int32(0)
        ifs := make([]*os.File, e.DiskNum)
        erg := new(errgroup.Group)

        for i, disk := range e.diskInfos[:e.DiskNum] </span><span class="cov8" title="1">{
                i := i
                disk := disk
                erg.Go(func() error </span><span class="cov8" title="1">{
                        folderPath := filepath.Join(disk.diskPath, baseFileName)
                        blobPath := filepath.Join(folderPath, "BLOB")
                        if !disk.available </span><span class="cov8" title="1">{
                                return &amp;diskError{disk.diskPath, " available flag set false"}
                        }</span>
                        <span class="cov8" title="1">ifs[i], err = os.Open(blobPath)
                        if err != nil </span><span class="cov0" title="0">{
                                disk.available = false
                                return err
                        }</span>

                        <span class="cov8" title="1">disk.available = true
                        atomic.AddInt32(&amp;alive, 1)
                        return nil</span>
                })
        }
        <span class="cov8" title="1">if err := erg.Wait(); err != nil </span><span class="cov8" title="1">{
                if !e.Quiet </span><span class="cov0" title="0">{
                        log.Printf("%s", err.Error())
                }</span>
        }
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                for i := 0; i &lt; e.DiskNum; i++ </span><span class="cov8" title="1">{
                        if ifs[i] != nil </span><span class="cov8" title="1">{
                                ifs[i].Close()
                        }</span>
                }
        }()
        <span class="cov8" title="1">if int(alive) &lt; e.K </span><span class="cov0" title="0">{
                //the disk renders inrecoverable
                return errTooFewDisksAlive
        }</span>
        //---------------------------------------
        //stripeOrder arranges the repairing order of each stripe
        //i.e., stripe[t] contains the failed stripe(s) that could be
        // recover in the t_th time slice. So on and so forth.
        <span class="cov8" title="1">var stripeOrder map[int][]int
        //---------------------------------------
        if int(alive) == e.DiskNum </span><span class="cov0" title="0">{
                if !e.Quiet </span><span class="cov0" title="0">{
                        log.Println("start reading blocks")
                }</span>
        } else<span class="cov8" title="1"> {
                if !e.Quiet </span><span class="cov0" title="0">{
                        log.Println("start reconstructing blocks")
                }</span>
                //--------------------------------
                <span class="cov8" title="1">if options.WithSGA </span><span class="cov0" title="0">{
                        fi.loadBalancedScheme, stripeOrder, err = e.SGA(fi, options.WithGCA)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                //-------------------------------
        }
        //for local save path
        <span class="cov8" title="1">sf, err := os.OpenFile(savepath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer sf.Close()

        //Since the file is striped, we have to reconstruct each stripe
        //for each stripe we rejoin the data
        numBlob := ceilFracInt(stripeNum, e.ConStripes)
        stripeCnt := 0
        nextStripe := 0
        //-----------------------------------
        //diskLoads records the load level of each disks(in blocks).
        diskLoads := make([]int32, e.DiskNum)
        //-----------------------------------

        //Without SGA: for every stripe pick up the first k alive blocks for repairing
        //With SGA: for maximal load-balance, pick up k alive blocks chosen by SGA
        //
        //Without GCA: the stripes are repaired in consecutive order
        //With GCA:  the stripes are repaired concurrently so that the total time slice is minimized
        for blob := 0; blob &lt; numBlob; blob++ </span><span class="cov8" title="1">{
                if stripeCnt+e.ConStripes &gt; stripeNum </span><span class="cov0" title="0">{
                        nextStripe = stripeNum - stripeCnt
                }</span> else<span class="cov8" title="1"> {
                        nextStripe = e.ConStripes
                }</span>
                <span class="cov8" title="1">eg := e.errgroupPool.Get().(*errgroup.Group)
                blobBuf := makeArr2DByte(e.ConStripes, int(e.allStripeSize))
                for s := 0; s &lt; nextStripe; s++ </span><span class="cov8" title="1">{
                        s := s
                        stripeNo := stripeCnt + s
                        // offset := int64(subCnt) * e.allStripeSize
                        func() error </span><span class="cov8" title="1">{
                                erg := e.errgroupPool.Get().(*errgroup.Group)
                                defer e.errgroupPool.Put(erg)
                                //read all blocks in parallel
                                //We only have to read k blocks to rec
                                failList := make(map[int]bool)
                                for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov8" title="1">{
                                        i := i
                                        diskId := dist[stripeNo][i]
                                        disk := e.diskInfos[diskId]
                                        blkStat := fi.blockInfos[stripeNo][i]
                                        if !disk.available || blkStat.bstat != blkOK </span><span class="cov8" title="1">{
                                                failList[diskId] = true
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">erg.Go(func() error </span><span class="cov8" title="1">{

                                                //we also need to know the block's accurate offset with respect to disk
                                                offset := fi.blockToOffset[stripeNo][i]
                                                _, err := ifs[diskId].ReadAt(blobBuf[s][int64(i)*e.BlockSize:int64(i+1)*e.BlockSize],
                                                        int64(offset)*e.BlockSize)
                                                // fmt.Println("Read ", n, " bytes at", i, ", block ", block)
                                                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">return nil</span>
                                        })
                                }
                                <span class="cov8" title="1">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                //Split the blob into k+m parts
                                <span class="cov8" title="1">splitData, err := e.splitStripe(blobBuf[s])
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                //verify and reconstruct if broken
                                <span class="cov8" title="1">ok, err := e.enc.Verify(splitData)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                //the failed ones are left to next step
                                <span class="cov8" title="1">if !ok &amp;&amp; !options.WithGCA </span><span class="cov8" title="1">{

                                        if options.WithSGA </span><span class="cov0" title="0">{
                                                err = e.enc.ReconstructWithKBlocks(splitData,
                                                        &amp;failList,
                                                        &amp;fi.loadBalancedScheme[stripeNo],
                                                        &amp;(fi.Distribution[stripeNo]),
                                                        options.Degrade)
                                        }</span> else<span class="cov8" title="1"> {
                                                err = e.enc.ReconstructWithList(splitData,
                                                        &amp;failList,
                                                        &amp;(fi.Distribution[stripeNo]),
                                                        options.Degrade)
                                        }</span>
                                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">tempCnt := 0
                                        for _, disk := range dist[stripeNo] </span><span class="cov8" title="1">{
                                                if _, ok := failList[disk]; !ok </span><span class="cov8" title="1">{
                                                        atomic.AddInt32(&amp;diskLoads[disk], 1)
                                                        tempCnt++
                                                        if tempCnt &gt;= e.K </span><span class="cov8" title="1">{
                                                                break</span>
                                                        }
                                                }
                                        }
                                }
                                //join and write to output file

                                <span class="cov8" title="1">for i := 0; i &lt; e.K; i++ </span><span class="cov8" title="1">{
                                        i := i
                                        writeOffset := int64(stripeNo)*e.dataStripeSize + int64(i)*e.BlockSize
                                        if fileSize-writeOffset &lt;= e.BlockSize </span><span class="cov8" title="1">{
                                                leftLen := fileSize - writeOffset
                                                _, err := sf.WriteAt(splitData[i][:leftLen], writeOffset)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov8" title="1">break</span>
                                        }
                                        <span class="cov8" title="1">erg.Go(func() error </span><span class="cov8" title="1">{
                                                // fmt.Println("i:", i, "writeOffset", writeOffset+e.BlockSize, "at stripe", subCnt)
                                                _, err := sf.WriteAt(splitData[i], writeOffset)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                // sf.Sync()
                                                <span class="cov8" title="1">return nil</span>
                                        })

                                }
                                <span class="cov8" title="1">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }()

                }
                <span class="cov8" title="1">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">e.errgroupPool.Put(eg)
                stripeCnt += nextStripe</span>
        }
        <span class="cov8" title="1">if options.WithGCA </span><span class="cov0" title="0">{
                //the reading upheld by GCA algorithm
                minTimeSlice := len(stripeOrder)
                for t := 1; t &lt;= minTimeSlice; t++ </span><span class="cov0" title="0">{
                        eg := e.errgroupPool.Get().(*errgroup.Group)
                        strps := stripeOrder[t]
                        blobBuf := makeArr2DByte(len(strps), int(e.allStripeSize))
                        for s, stripeNo := range strps </span><span class="cov0" title="0">{
                                stripeNo := stripeNo
                                s := s
                                eg.Go(func() error </span><span class="cov0" title="0">{
                                        erg := e.errgroupPool.Get().(*errgroup.Group)
                                        defer e.errgroupPool.Put(erg)
                                        //read all blocks in parallel
                                        //We only have to read k blocks to rec
                                        failList := make(map[int]bool)
                                        for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                                i := i
                                                diskId := dist[stripeNo][i]
                                                disk := e.diskInfos[diskId]
                                                blkStat := fi.blockInfos[stripeNo][i]
                                                if !disk.available || blkStat.bstat != blkOK </span><span class="cov0" title="0">{
                                                        failList[diskId] = true
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">erg.Go(func() error </span><span class="cov0" title="0">{

                                                        //we also need to know the block's accurate offset with respect to disk
                                                        offset := fi.blockToOffset[stripeNo][i]
                                                        _, err := ifs[diskId].ReadAt(blobBuf[s][int64(i)*e.BlockSize:int64(i+1)*e.BlockSize],
                                                                int64(offset)*e.BlockSize)
                                                        // fmt.Println("Read ", n, " bytes at", i, ", block ", block)
                                                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">return nil</span>
                                                })
                                        }
                                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        //Split the blob into k+m parts
                                        <span class="cov0" title="0">splitData, err := e.splitStripe(blobBuf[s])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        //must be broken so verifying is needless
                                        // ok, err := e.enc.Verify(splitData)
                                        // if err != nil {
                                        //         return err
                                        // }
                                        // if !ok {

                                        <span class="cov0" title="0">err = e.enc.ReconstructWithKBlocks(splitData,
                                                &amp;failList,
                                                &amp;fi.loadBalancedScheme[stripeNo],
                                                &amp;(fi.Distribution[stripeNo]),
                                                options.Degrade)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        //----------------------------------------
                                        <span class="cov0" title="0">tempCnt := 0
                                        for _, disk := range fi.loadBalancedScheme[stripeNo] </span><span class="cov0" title="0">{
                                                if _, ok := failList[disk]; !ok </span><span class="cov0" title="0">{
                                                        atomic.AddInt32(&amp;diskLoads[disk], 1)
                                                        tempCnt++
                                                        if tempCnt &gt;= e.K </span><span class="cov0" title="0">{
                                                                break</span>
                                                        }
                                                }
                                        }
                                        //---------------------------------------
                                        // }
                                        //join and write to output file

                                        <span class="cov0" title="0">for i := 0; i &lt; e.K; i++ </span><span class="cov0" title="0">{
                                                i := i
                                                writeOffset := int64(stripeNo)*e.dataStripeSize + int64(i)*e.BlockSize
                                                if fileSize-writeOffset &lt;= e.BlockSize </span><span class="cov0" title="0">{
                                                        leftLen := fileSize - writeOffset
                                                        _, err := sf.WriteAt(splitData[i][:leftLen], writeOffset)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">break</span>
                                                }
                                                <span class="cov0" title="0">erg.Go(func() error </span><span class="cov0" title="0">{
                                                        // fmt.Println("i:", i, "writeOffset", writeOffset+e.BlockSize, "at stripe", subCnt)
                                                        _, err := sf.WriteAt(splitData[i], writeOffset)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        // sf.Sync()
                                                        <span class="cov0" title="0">return nil</span>
                                                })

                                        }
                                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">return err</span>
                                })
                        }
                        <span class="cov0" title="0">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">e.errgroupPool.Put(eg)</span>
                }
        }
        <span class="cov8" title="1">if !e.Quiet </span><span class="cov0" title="0">{
                //--------------------------------------------
                fmt.Printf("------------------Normal--------------------")
                maxload, sumload := 0, 0
                for i := range diskLoads </span><span class="cov0" title="0">{
                        maxload = max(maxload, int(diskLoads[i]))
                        sumload += int(diskLoads[i])
                }</span>
                <span class="cov0" title="0">fmt.Printf("\nmaxLoad:%d, sumLoad: %d\n", maxload, sumload)
                fmt.Printf("disk loads:\n%v\n", diskLoads)
                //-------------------------------------------
                log.Printf("reading %s...", filename)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (e *Erasure) splitStripe(data []byte) ([][]byte, error) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, reedsolomon.ErrShortData
        }</span>
        // Calculate number of bytes per data shard.
        <span class="cov8" title="1">perShard := ceilFracInt(len(data), e.K+e.M)

        // Split into equal-length shards.
        dst := make([][]byte, e.K+e.M)
        i := 0
        for ; i &lt; len(dst) &amp;&amp; len(data) &gt;= perShard; i++ </span><span class="cov8" title="1">{
                dst[i], data = data[:perShard:perShard], data[perShard:]
        }</span>

        <span class="cov8" title="1">return dst, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package grasure

import (
        "io"
        "log"
        "os"
        "path/filepath"

        "golang.org/x/sync/errgroup"
)

//get the number of files
func (e *Erasure) getFileNum() int <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()
        fileNum := 0
        e.fileMap.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                fileNum++
                return true
        }</span>)
        <span class="cov0" title="0">return fileNum</span>

}

//RecoverReadFull mainly deals with a disk-level disaster reconstruction.
//User should provide enough backup devices in `.hdr.disk.path` for data transferring.
//
//An (oldPath -&gt; replacedPath) replace map is returned in the first placeholder.
func (e *Erasure) Recover(options *Options) (map[string]string, error) <span class="cov0" title="0">{
        totalFiles := e.getFileNum()
        if !e.Quiet </span><span class="cov0" title="0">{
                log.Printf("Start recovering, totally %d files need recovery",
                        totalFiles)
        }</span> //first, make clear how many disks need to be recovered
        //Second, match backup partners
        //Third, concurrently recover the part of the files
        <span class="cov0" title="0">failNum := 0
        for i := 0; i &lt; e.DiskNum; i++ </span><span class="cov0" title="0">{
                if !e.diskInfos[i].available </span><span class="cov0" title="0">{
                        failNum++
                }</span>
        }
        <span class="cov0" title="0">if failNum == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        //the failure number exceeds the fault tolerance
        <span class="cov0" title="0">if failNum &gt; e.M </span><span class="cov0" title="0">{
                return nil, errTooFewDisksAlive
        }</span>
        //the failure number doesn't exceed the fault tolerance
        //but unluckily we don't have enough backups!
        <span class="cov0" title="0">if failNum &gt; len(e.diskInfos)-e.DiskNum </span><span class="cov0" title="0">{
                return nil, errNotEnoughBackupForRecovery
        }</span>
        //the failed disks are mapped to backup disks
        <span class="cov0" title="0">replaceMap := make(map[int]int)
        ReplaceMap := make(map[string]string)
        diskFailList := make(map[int]bool, failNum)
        j := e.DiskNum
        // think what if backup also breaks down, future stuff
        for i := 0; i &lt; e.DiskNum; i++ </span><span class="cov0" title="0">{
                if !e.diskInfos[i].available </span><span class="cov0" title="0">{
                        ReplaceMap[e.diskInfos[i].diskPath] = e.diskInfos[j].diskPath
                        replaceMap[i] = j
                        diskFailList[i] = true
                        j++
                }</span>
        }
        //start recovering: traversing the files

        <span class="cov0" title="0">erg := new(errgroup.Group)
        // var ifpool, rfpool sync.Pool
        // ifpool.New = func() interface{} {
        //         out := make([]*os.File, e.DiskNum)
        //         return &amp;out
        // }
        // rfpool.New = func() interface{} {
        //         out := make([]*os.File, failNum)
        //         return &amp;out
        // }
        e.fileMap.Range(func(filename, fi interface{}) bool </span><span class="cov0" title="0">{
                basefilename := filename.(string)
                fd := fi.(*fileInfo)
                //These files can be repaired concurrently
                // rfs := *rfpool.Get().(*[]*os.File) //restore fs
                // ifs := *ifpool.Get().(*[]*os.File)
                // defer rfpool.Put(&amp;rfs)
                // defer rfpool.Put(&amp;ifs)
                ifs := make([]*os.File, e.DiskNum)
                rfs := make([]*os.File, failNum)
                erg.Go(func() error </span><span class="cov0" title="0">{
                        //read the current disks
                        erg := e.errgroupPool.Get().(*errgroup.Group)
                        defer e.errgroupPool.Put(erg)
                        for i, disk := range e.diskInfos[:e.DiskNum] </span><span class="cov0" title="0">{
                                i := i
                                disk := disk
                                erg.Go(func() error </span><span class="cov0" title="0">{
                                        folderPath := filepath.Join(disk.diskPath, basefilename)
                                        blobPath := filepath.Join(folderPath, "BLOB")
                                        if !disk.available </span><span class="cov0" title="0">{
                                                ifs[i] = nil
                                                return nil
                                        }</span>
                                        <span class="cov0" title="0">ifs[i], err = os.Open(blobPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">return nil</span>
                                })
                        }
                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                                for i := 0; i &lt; e.DiskNum; i++ </span><span class="cov0" title="0">{
                                        if ifs[i] != nil </span><span class="cov0" title="0">{
                                                ifs[i].Close()
                                        }</span>
                                }
                        }()
                        //open restore path IOs
                        <span class="cov0" title="0">for i, disk := range e.diskInfos[e.DiskNum : e.DiskNum+failNum] </span><span class="cov0" title="0">{
                                i := i
                                disk := disk
                                erg.Go(func() error </span><span class="cov0" title="0">{
                                        folderPath := filepath.Join(disk.diskPath, basefilename)
                                        blobPath := filepath.Join(folderPath, "BLOB")
                                        if e.Override </span><span class="cov0" title="0">{
                                                if err := os.RemoveAll(folderPath); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if err := os.Mkdir(folderPath, 0666); err != nil </span><span class="cov0" title="0">{
                                                return errDataDirExist
                                        }</span>
                                        <span class="cov0" title="0">rfs[i], err = os.OpenFile(blobPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        <span class="cov0" title="0">return nil</span>
                                })
                        }
                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                                for i := 0; i &lt; failNum; i++ </span><span class="cov0" title="0">{
                                        if rfs[i] != nil </span><span class="cov0" title="0">{
                                                rfs[i].Close()
                                        }</span>
                                }
                        }()
                        //recover the file and write to restore path
                        //we read the survival blocks
                        //Since the file is striped, we have to reconstruct each stripe
                        //for each stripe we rejoin the data
                        <span class="cov0" title="0">stripeNum := len(fd.Distribution)
                        dist := fd.Distribution
                        numBlob := ceilFracInt(stripeNum, e.ConStripes)
                        stripeCnt := 0
                        nextStripe := 0
                        blobBuf := makeArr2DByte(e.ConStripes, int(e.allStripeSize))
                        for blob := 0; blob &lt; numBlob; blob++ </span><span class="cov0" title="0">{
                                if stripeCnt+e.ConStripes &gt; stripeNum </span><span class="cov0" title="0">{
                                        nextStripe = stripeNum - stripeCnt
                                }</span> else<span class="cov0" title="0"> {
                                        nextStripe = e.ConStripes
                                }</span>
                                <span class="cov0" title="0">eg := e.errgroupPool.Get().(*errgroup.Group)
                                for s := 0; s &lt; nextStripe; s++ </span><span class="cov0" title="0">{
                                        s := s
                                        stripeNo := stripeCnt + s
                                        // offset := int64(subCnt) * e.allStripeSize
                                        eg.Go(func() error </span><span class="cov0" title="0">{
                                                erg := e.errgroupPool.Get().(*errgroup.Group)
                                                defer e.errgroupPool.Put(erg)
                                                //read all blocks in parallel
                                                //there are three cases of repairing
                                                //1. none of the failed disks contain the blocks
                                                //2. some of the failed disks contain the blocks
                                                //3. all of the failed disks contain the blocks
                                                for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                                        i := i
                                                        diskId := dist[stripeNo][i]
                                                        disk := e.diskInfos[diskId]
                                                        if !disk.available </span><span class="cov0" title="0">{
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">erg.Go(func() error </span><span class="cov0" title="0">{
                                                                //we also need to know the block's accurate offset with respect to disk
                                                                offset := fd.blockToOffset[stripeNo][i]
                                                                _, err := ifs[diskId].ReadAt(blobBuf[s][int64(i)*e.BlockSize:int64(i+1)*e.BlockSize],
                                                                        int64(offset)*e.BlockSize)
                                                                // fmt.Println("Read ", n, " bytes at", i, ", block ", block)
                                                                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                                                        return err
                                                                }</span>
                                                                <span class="cov0" title="0">return nil</span>
                                                        })
                                                }
                                                <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                //Split the blob into k+m parts
                                                <span class="cov0" title="0">splitData, err := e.splitStripe(blobBuf[s])
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov0" title="0">ok, err := e.enc.Verify(splitData)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                                        err = e.enc.ReconstructWithList(splitData, &amp;diskFailList, &amp;(fd.Distribution[stripeNo]), options.Degrade)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                } else<span class="cov0" title="0"> {
                                                        return nil
                                                }</span>
                                                //write the Blob to restore paths
                                                <span class="cov0" title="0">egp := e.errgroupPool.Get().(*errgroup.Group)
                                                defer e.errgroupPool.Put(egp)
                                                for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                                        i := i
                                                        diskId := dist[stripeNo][i]
                                                        if v, ok := replaceMap[diskId]; ok </span><span class="cov0" title="0">{
                                                                restoreId := v - e.DiskNum
                                                                writeOffset := fd.blockToOffset[stripeNo][i]
                                                                egp.Go(func() error </span><span class="cov0" title="0">{
                                                                        _, err := rfs[restoreId].WriteAt(splitData[i],
                                                                                int64(writeOffset)*e.BlockSize)
                                                                        if err != nil </span><span class="cov0" title="0">{
                                                                                return err
                                                                        }</span>
                                                                        <span class="cov0" title="0">if e.diskInfos[diskId].ifMetaExist </span><span class="cov0" title="0">{
                                                                                newMetapath := filepath.Join(e.diskInfos[restoreId].diskPath, "META")
                                                                                if _, err := copyFile(e.ConfigFile, newMetapath); err != nil </span><span class="cov0" title="0">{
                                                                                        return err
                                                                                }</span>
                                                                        }
                                                                        <span class="cov0" title="0">return nil</span>

                                                                })

                                                        }
                                                }
                                                <span class="cov0" title="0">if err := egp.Wait(); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                                <span class="cov0" title="0">return nil</span>
                                        })

                                }
                                <span class="cov0" title="0">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">e.errgroupPool.Put(eg)
                                stripeCnt += nextStripe</span>

                        }
                        <span class="cov0" title="0">if !e.Quiet </span><span class="cov0" title="0">{
                                log.Printf("reading %s!", filename)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">return true</span>
        })
        //do not forget to recover the meta replicas
        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = e.updateDiskPath(replaceMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !e.Quiet </span><span class="cov0" title="0">{
                log.Println("Finish recovering")
        }</span>
        <span class="cov0" title="0">return ReplaceMap, nil</span>
}

//Update the diskpath. Reserve the current diskPathFile and write new one.
func (e *Erasure) updateDiskPath(replaceMap map[int]int) error <span class="cov0" title="0">{
        // the last step: after recovering the files, we update `.hdr.disks.path`
        // and write a copy
        //1. rename the file
        err := os.Rename(e.DiskFilePath, e.DiskFilePath+".old")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //2. update e.DiskFilePath
        <span class="cov0" title="0">for k, v := range replaceMap </span><span class="cov0" title="0">{
                e.diskInfos[k] = e.diskInfos[v]
        }</span>
        // A little trick on removal of center elements
        <span class="cov0" title="0">fn := len(replaceMap)
        e.diskInfos = e.diskInfos[:e.DiskNum+
                copy(e.diskInfos[e.DiskNum:], e.diskInfos[e.DiskNum+fn:])]
        //3.write to new file
        f, err := os.OpenFile(e.DiskFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer f.Close()
        for _, di := range e.diskInfos </span><span class="cov0" title="0">{
                _, err = f.WriteString(di.diskPath + "\n")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package grasure

import "github.com/DurantVivado/reedsolomon"

// Scale expands the storage system to a new k and new m, for example,
// Start with a (2,1) system but with more data flouring into, the system needs to be scaled to
// a larger system, say (6,4).
//
//One advantage is that a bigger k supports higher storage efficiency.
//
//Another is that requirement of fault tolerance may level up when needed.
//
//It unavoidably incurrs serious data migration. We are working to minimize the traffic.
func (e *Erasure) Scale(new_k, new_m int) error <span class="cov0" title="0">{
        if new_k &lt;= 0 || new_m &lt;= 0 </span><span class="cov0" title="0">{
                return reedsolomon.ErrInvShardNum
        }</span>
        <span class="cov0" title="0">if new_k+new_m &gt; 256 </span><span class="cov0" title="0">{
                return reedsolomon.ErrMaxShardNum
        }</span>
        <span class="cov0" title="0">if new_k+new_m &gt; e.DiskNum </span><span class="cov0" title="0">{
                return errTooFewDisksAlive
        }</span>
        <span class="cov0" title="0">if new_k == e.K &amp;&amp; new_m == e.M </span><span class="cov0" title="0">{
                return nil
        }</span>
        //step 1: modify the struct
        //step 2: migrate data as well as replicas
        //step 3: reorganize layout to conform to randomized distribution (other forms applies)
        //step 4: write the new config and update replicas
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package grasure

import (
        "fmt"
        "log"
        "path/filepath"
        "strconv"
        "strings"
)

//the proportion of stripe where bitrot occurs of all stripes
const stripeFailProportion = 0.3

//Destroy simulates disk failure or bitrot:
//
//for `diskFail mode`, `failNum` random disks are marked as unavailable, `failName` is ignored.
//
// for `bitRot`, `failNum` random blocks in a stripe of the file corrupts, that only works in Read Mode;
//
// Since it's a simulation, no real data will be lost.
// Note that failNum = min(failNum, DiskNum).
func (e *Erasure) Destroy(simOption *SimOptions) <span class="cov0" title="0">{
        //if disk is currently unhealthy then give up
        if !e.isDiskHealthy() </span><span class="cov0" title="0">{
                return
        }</span>
        //if failDisk is specialized, then use that
        <span class="cov0" title="0">if simOption.FailDisk != "" </span><span class="cov0" title="0">{
                disks := strings.Split(simOption.FailDisk, ",")
                for _, d := range disks </span><span class="cov0" title="0">{
                        dd, _ := strconv.Atoi(d)
                        e.diskInfos[dd].available = false
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if simOption.Mode == "diskFail" || simOption.Mode == "DiskFail" </span><span class="cov0" title="0">{
                if simOption.FailNum &lt;= 0 </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if simOption.FailNum &gt; e.DiskNum </span><span class="cov0" title="0">{
                        simOption.FailNum = e.DiskNum
                }</span>

                //we randomly picked up failNum disks and mark as unavailable
                <span class="cov0" title="0">if !e.Quiet </span><span class="cov0" title="0">{
                        log.Println("simulate failure on:")
                }</span>

                <span class="cov0" title="0">shuff := genRandomArr(e.DiskNum, 0)
                for i := 0; i &lt; simOption.FailNum; i++ </span><span class="cov0" title="0">{

                        if !e.Quiet </span><span class="cov0" title="0">{
                                log.Println(e.diskInfos[shuff[i]].diskPath)
                        }</span>
                        <span class="cov0" title="0">e.diskInfos[shuff[i]].available = false</span>
                }
        } else<span class="cov0" title="0"> if simOption.Mode == "bitRot" || simOption.Mode == "BitRot" </span><span class="cov0" title="0">{
                //in thi smode, we don't really corrupt a bit. Instead, we mark the block containing rots as failed
                // which is omnipresent is today's storage facilities.
                //if fileName is "", we corrupt all the files, else corrupt specific file
                if simOption.FailNum &gt; e.K+e.M </span><span class="cov0" title="0">{
                        simOption.FailNum = e.K + e.M
                }</span>
                <span class="cov0" title="0">if simOption.FileName == "" </span><span class="cov0" title="0">{
                        e.fileMap.Range(func(filename, fi interface{}) bool </span><span class="cov0" title="0">{
                                fd := fi.(*fileInfo)
                                //of course the bitrot must be random, and pesudo-random
                                //algorithms have flaws. For every stripe, we corrupt failNum blocks
                                stripeNum := len(fd.blockInfos)
                                stripeFail := int(stripeFailProportion * float32(stripeNum))
                                for i := range genRandomArr(stripeNum, 0)[:stripeFail] </span><span class="cov0" title="0">{

                                        for j := range genRandomArr(e.K+e.M, 0)[:simOption.FailNum] </span><span class="cov0" title="0">{
                                                fd.blockInfos[i][j].bstat = blkFail
                                        }</span>
                                }
                                <span class="cov0" title="0">return true</span>
                        })
                } else<span class="cov0" title="0"> {
                        baseFileName := filepath.Base(simOption.FileName)
                        intFi, ok := e.fileMap.Load(baseFileName)
                        if !ok </span><span class="cov0" title="0">{
                                log.Fatal(errFileNotFound)
                        }</span>
                        <span class="cov0" title="0">fi := intFi.(*fileInfo)

                        //of course the bitrot must be random, and pesudo-random
                        //algorithms have flaws. For every stripe, we corrupt simOption.FailNum blocks
                        stripeNum := len(fi.blockInfos)
                        stripeFail := int(stripeFailProportion * float32(stripeNum))
                        strps := genRandomArr(stripeNum, 0)[:stripeFail]
                        for _, i := range strps </span><span class="cov0" title="0">{

                                blks := genRandomArr(e.K+e.M, 0)[:simOption.FailNum]
                                for _, j := range blks </span><span class="cov0" title="0">{
                                        // fmt.Printf("i:%d, j :%d fails.\n", i, j)
                                        fi.blockInfos[i][j].bstat = blkFail
                                }</span>
                        }

                }
        } else<span class="cov0" title="0"> {
                log.Fatal("please specialize failMode in diskFail and bitRot")
        }</span>
}

//print disk status
func (e *Erasure) printDiskStatus() <span class="cov0" title="0">{
        for i, disk := range e.diskInfos </span><span class="cov0" title="0">{

                fmt.Printf("DiskId:%d, available:%tn,numBlocks:%d, storage:%d/%d (bytes)\n",
                        i, disk.available, disk.numBlocks, int64(disk.numBlocks)*e.BlockSize, disk.capacity)
        }</span>
}

//check system health
// 1. if currently working disks' number is less than DiskNum, inform the user
func (e *Erasure) isDiskHealthy() bool <span class="cov0" title="0">{
        for _, v := range e.diskInfos[:e.DiskNum] </span><span class="cov0" title="0">{
                if !v.available </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package grasure

import (
        "bytes"
        "errors"
        "io"
        "log"
        "os"
        "path/filepath"
        "sort"
        "sync/atomic"

        "golang.org/x/sync/errgroup"
)

//update a file according to a new file, the local `filename` will be used to update the file in the cloud with the same name
func (e *Erasure) Update(oldFile, newFile string) error <span class="cov0" title="0">{
        // read old file info
        baseName := filepath.Base(oldFile)
        intFi, ok := e.fileMap.Load(baseName)
        if !ok </span><span class="cov0" title="0">{
                return errFileNotFound
        }</span>
        <span class="cov0" title="0">fi := intFi.(*fileInfo)
        // update file info
        nf, err := os.Open(newFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer nf.Close()
        fileInfo, err := nf.Stat()
        oldFileSize := fi.FileSize
        fi.FileSize = fileInfo.Size()
        hashStr, err := hashStr(nf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fi.Hash = hashStr

        // open file as io.Reader
        alive := int32(0)
        diskNum := len(e.diskInfos)
        ifs := make([]*os.File, diskNum)
        erg := new(errgroup.Group)
        diskFail := false
        for i, disk := range e.diskInfos[:e.DiskNum] </span><span class="cov0" title="0">{
                i := i
                disk := disk
                erg.Go(func() error </span><span class="cov0" title="0">{
                        folderPath := filepath.Join(disk.diskPath, baseName)
                        blobPath := filepath.Join(folderPath, "BLOB")
                        if !disk.available </span><span class="cov0" title="0">{
                                diskFail = true
                                return &amp;diskError{disk.diskPath, " avilable flag set flase"}
                        }</span>
                        <span class="cov0" title="0">ifs[i], err = os.OpenFile(blobPath, os.O_RDWR|os.O_TRUNC, 0666)
                        if err != nil </span><span class="cov0" title="0">{
                                disk.available = false
                                return err
                        }</span>

                        <span class="cov0" title="0">disk.available = true
                        atomic.AddInt32(&amp;alive, 1)
                        return nil</span>
                })
        }
        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                if !e.Quiet </span><span class="cov0" title="0">{
                        log.Printf("read failed %s", err.Error())
                }</span>
                <span class="cov0" title="0">if diskFail </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                for i := range e.diskInfos </span><span class="cov0" title="0">{
                        ifs[i].Close()
                }</span>
        }()
        <span class="cov0" title="0">if int(alive) &lt; e.K </span><span class="cov0" title="0">{
                //the disk renders inrecoverable
                return errTooFewDisksAlive
        }</span>
        <span class="cov0" title="0">if int(alive) == e.DiskNum </span><span class="cov0" title="0">{
                if !e.Quiet </span><span class="cov0" title="0">{
                        log.Println("start reading blocks")
                }</span>
        } else<span class="cov0" title="0"> {
                if !e.Quiet </span><span class="cov0" title="0">{
                        log.Println("start reconstructing blocks")
                }</span>
        }

        <span class="cov0" title="0">oldStripeNum := int(ceilFracInt64(oldFileSize, e.dataStripeSize))
        newStripeNum := int(ceilFracInt64(fi.FileSize, e.dataStripeSize))
        // fmt.Println(oldStripeNum, newStripeNum)
        numBlob := ceilFracInt(newStripeNum, e.ConStripes)
        adjustDist(e, fi, oldStripeNum, newStripeNum)

        stripeCnt := 0
        nextStripe := 0
        dist := fi.Distribution
        newBlobBuf := makeArr2DByte(e.ConStripes, int(e.dataStripeSize))
        oldBlobBuf := makeArr2DByte(e.ConStripes, int(e.allStripeSize))
        for blob := 0; blob &lt; numBlob; blob++ </span><span class="cov0" title="0">{
                if stripeCnt+e.ConStripes &gt; newStripeNum </span><span class="cov0" title="0">{
                        nextStripe = newStripeNum - stripeCnt
                }</span> else<span class="cov0" title="0"> {
                        nextStripe = e.ConStripes
                }</span>
                <span class="cov0" title="0">eg := e.errgroupPool.Get().(*errgroup.Group)
                // newBlobBuf := *e.dataBlobPool.Get().(*[][]byte)
                // oldBlobBuf := *e.allBlobPool.Get().(*[][]byte)
                for s := 0; s &lt; nextStripe; s++ </span><span class="cov0" title="0">{
                        s := s
                        stripeNo := stripeCnt + s
                        if stripeNo &lt; oldStripeNum </span><span class="cov0" title="0">{
                                // read old data shards
                                // fmt.Println("old")
                                eg.Go(func() error </span><span class="cov0" title="0">{
                                        erg := e.errgroupPool.Get().(*errgroup.Group)
                                        defer e.errgroupPool.Put(erg)
                                        for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                                i := i
                                                erg.Go(func() error </span><span class="cov0" title="0">{
                                                        diskID := dist[stripeNo][i]
                                                        disk := e.diskInfos[diskID]
                                                        if !disk.available </span><span class="cov0" title="0">{
                                                                return nil
                                                        }</span>
                                                        <span class="cov0" title="0">offset := fi.blockToOffset[stripeNo][i]
                                                        _, err := ifs[diskID].ReadAt(oldBlobBuf[s][int64(i)*e.BlockSize:int64(i+1)*e.BlockSize],
                                                                int64(offset)*e.BlockSize)
                                                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">return nil</span>
                                                })
                                        }
                                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        //Split the blob into k+m parts
                                        <span class="cov0" title="0">oldData, err := e.splitStripe(oldBlobBuf[s])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        //verify and reconstruct
                                        <span class="cov0" title="0">ok, err := e.enc.Verify(oldData)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                                                // fmt.Println("reconstruct data of stripe:", stripeNo)
                                                err = e.enc.Reconstruct(oldData)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                        // read new data shards
                                        <span class="cov0" title="0">offset := int64(stripeCnt+s) * e.dataStripeSize
                                        _, err = nf.ReadAt(newBlobBuf[s], offset)
                                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">newData, err := e.enc.Split(newBlobBuf[s])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        // compare
                                        <span class="cov0" title="0">diffIdx, err := compareStripe(oldData[0:e.K], newData[0:e.K])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        // if no data has been changed,
                                        <span class="cov0" title="0">if diffIdx == nil </span><span class="cov0" title="0">{
                                                return nil
                                        }</span>
                                        // we create the argments of Update
                                        <span class="cov0" title="0">shards := make([][]byte, e.K+e.M)
                                        for i := range shards </span><span class="cov0" title="0">{
                                                shards[i] = make([]byte, e.BlockSize)
                                        }</span>
                                        <span class="cov0" title="0">for i := range oldData </span><span class="cov0" title="0">{
                                                if i &gt;= e.K || sort.SearchInts(diffIdx, i) != len(diffIdx) </span><span class="cov0" title="0">{
                                                        copy(shards[i], oldData[i])
                                                }</span> else<span class="cov0" title="0"> {
                                                        shards[i] = nil
                                                        newData[i] = nil
                                                }</span>
                                        }
                                        // update
                                        <span class="cov0" title="0">err = e.enc.Update(shards, newData[0:e.K])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        // we write back the changed data blocks and all parity blocks
                                        <span class="cov0" title="0">for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                                i := i
                                                if shards[i] == nil </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">newBlock := make([]byte, e.BlockSize)
                                                if i &gt;= e.K </span><span class="cov0" title="0">{
                                                        copy(newBlock, shards[i])
                                                }</span> else<span class="cov0" title="0"> {
                                                        copy(newBlock, newData[i])
                                                }</span>
                                                <span class="cov0" title="0">erg.Go(func() error </span><span class="cov0" title="0">{
                                                        diskID := fi.Distribution[stripeNo][i]
                                                        offset := fi.blockToOffset[stripeNo][i]
                                                        _, err := ifs[diskID].WriteAt(newBlock, int64(offset)*e.BlockSize)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">return nil</span>
                                                })
                                        }
                                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                })
                        } else<span class="cov0" title="0"> {
                                // if new filesize is greater than old filesize, we just encode the remaining data
                                // fmt.Println("new")
                                eg.Go(func() error </span><span class="cov0" title="0">{
                                        offset := int64(stripeNo) * e.dataStripeSize
                                        _, err = nf.ReadAt(newBlobBuf[s], offset)
                                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">newData, err := e.enc.Split(newBlobBuf[s])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">err = e.enc.Encode(newData)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">erg := e.errgroupPool.Get().(*errgroup.Group)
                                        defer e.errgroupPool.Put(erg)
                                        for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                                i := i
                                                erg.Go(func() error </span><span class="cov0" title="0">{
                                                        a := i
                                                        diskID := fi.Distribution[stripeNo][a]
                                                        writeOffset := fi.blockToOffset[stripeNo][a]
                                                        _, err := ifs[diskID].WriteAt(newData[a], int64(writeOffset)*e.BlockSize)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">return nil</span>
                                                })
                                        }
                                        <span class="cov0" title="0">if err := erg.Wait(); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                })
                        }

                }
                <span class="cov0" title="0">if err := eg.Wait(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.errgroupPool.Put(eg)
                stripeCnt += nextStripe</span>
        }

        <span class="cov0" title="0">if !e.Quiet </span><span class="cov0" title="0">{
                log.Println(baseName, " successfully updated.")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// compare the oldStripe and newStripe and return the different blocks' index
// if oldStripe == newStripe, return nil
func compareStripe(oldStripe, newStripe [][]byte) ([]int, error) <span class="cov0" title="0">{
        if len(oldStripe) != len(newStripe) </span><span class="cov0" title="0">{
                return nil, errors.New("compare error: Invalid Input")
        }</span>
        <span class="cov0" title="0">res := make([]int, 0)
        for i := range oldStripe </span><span class="cov0" title="0">{
                if !bytes.Equal(oldStripe[i], newStripe[i]) </span><span class="cov0" title="0">{
                        res = append(res, i)
                }</span>
        }
        <span class="cov0" title="0">if len(res) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func adjustDist(e *Erasure, fi *fileInfo, oldStripeNum, newStripeNum int) <span class="cov0" title="0">{
        countSum := make([]int, e.DiskNum)
        if newStripeNum &gt; oldStripeNum </span><span class="cov0" title="0">{
                for i := 0; i &lt; newStripeNum-oldStripeNum; i++ </span><span class="cov0" title="0">{
                        fi.Distribution = append(fi.Distribution, make([]int, e.K+e.M))
                        fi.blockToOffset = append(fi.blockToOffset, make([]int, e.K+e.M))
                }</span>
                <span class="cov0" title="0">for i := 0; i &lt; oldStripeNum; i++ </span><span class="cov0" title="0">{
                        for j := 0; j &lt; e.K+e.M; j++ </span><span class="cov0" title="0">{
                                diskId := fi.Distribution[i][j]
                                countSum[diskId]++
                        }</span>
                }
                <span class="cov0" title="0">for i := oldStripeNum; i &lt; newStripeNum; i++ </span><span class="cov0" title="0">{
                        fi.Distribution[i] = genRandomArr(e.DiskNum, 0)[0 : e.K+e.M]
                        for j := 0; j &lt; e.K+e.M; j++ </span><span class="cov0" title="0">{
                                diskID := fi.Distribution[i][j]
                                fi.blockToOffset[i][j] = countSum[diskID]
                                countSum[diskID]++
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                fi.Distribution = fi.Distribution[0:newStripeNum]
                fi.blockToOffset = fi.blockToOffset[0:newStripeNum]
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package grasure

import (
        "bufio"
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "math/rand"
        "os"
        "os/signal"
        "runtime"
        "strconv"
        "strings"
        "syscall"
        "time"
)

//A Go-version Set
type IntSet map[int]struct{}

func (is *IntSet) Insert(x int) <span class="cov0" title="0">{
        if *is == nil </span><span class="cov0" title="0">{
                *is = make(IntSet)
        }</span>
        <span class="cov0" title="0">(*is)[x] = struct{}{}</span>
}
func (is *IntSet) Exist(x int) bool <span class="cov0" title="0">{
        if *is == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">_, ok := (*is)[x]
        return ok</span>
}
func (is *IntSet) Erase(x int) <span class="cov0" title="0">{
        if *is == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !is.Exist(x) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">delete(*is, x)</span>
}
func (is *IntSet) Clear() <span class="cov0" title="0">{
        if *is == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for k, _ := range *is </span><span class="cov0" title="0">{
                delete(*is, k)
        }</span>
}
func (is *IntSet) Empty() bool <span class="cov0" title="0">{
        if *is == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return len(*is) == 0</span>
}
func (is *IntSet) Size() int <span class="cov0" title="0">{
        if *is == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return len(*is)</span>
}

func sumInt(arrs []int, base int) int <span class="cov0" title="0">{
        sum := base
        for i := range arrs </span><span class="cov0" title="0">{
                sum += arrs[i]
        }</span>
        <span class="cov0" title="0">return sum</span>
}

//consult user to avoid maloperation
func consultUserBeforeAction() (bool, error) <span class="cov0" title="0">{
        fmt.Println("If you are sure to proceed, type:\n [Y]es or [N]o.")
        inputReader := bufio.NewReader(os.Stdin)
        for </span><span class="cov0" title="0">{
                ans, err := inputReader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">ans = strings.TrimSuffix(ans, "\n")
                if ans == "Y" || ans == "y" || ans == "Yes" || ans == "yes" </span><span class="cov0" title="0">{
                        return true, nil
                }</span> else<span class="cov0" title="0"> if ans == "N" || ans == "n" || ans == "No" || ans == "no" </span><span class="cov0" title="0">{
                        return false, nil
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Please do not make joke")
                }</span>
        }

}

//an instant error dealer

//look if path exists
func pathExist(path string) (bool, error) <span class="cov8" title="1">{
        _, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return false, err</span>
}

//ceilFrac return (a+b-1)/b
func ceilFracInt(a, b int) int <span class="cov8" title="1">{
        return (a + b - 1) / b
}</span>

//ceilFrac return (a+b-1)/b
func ceilFracInt64(a, b int64) int64 <span class="cov8" title="1">{
        return (a + b - 1) / b
}</span>

func min(args ...int) int <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return 0x7fffffff
        }</span>
        <span class="cov0" title="0">ret := args[0]
        for _, arg := range args </span><span class="cov0" title="0">{
                if arg &lt; ret </span><span class="cov0" title="0">{
                        ret = arg
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}

func max(args ...int) int <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return 0xffffffff
        }</span>
        <span class="cov0" title="0">ret := args[0]
        for _, arg := range args </span><span class="cov0" title="0">{
                if arg &gt; ret </span><span class="cov0" title="0">{
                        ret = arg
                }</span>
        }
        <span class="cov0" title="0">return ret</span>
}

//each stripe randomized distribution
func genRandomArr(n, start int) []int <span class="cov8" title="1">{
        shuff := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                shuff[i] = i + start
        }</span>
        <span class="cov8" title="1">rand.Seed(time.Now().UnixNano())
        rand.Shuffle(len(shuff), func(i, j int) </span><span class="cov8" title="1">{ shuff[i], shuff[j] = shuff[j], shuff[i] }</span>)
        <span class="cov8" title="1">return shuff</span>
}

//get arr of default sequence
func getSeqArr(n int) []int <span class="cov0" title="0">{
        out := make([]int, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                out[i] = i
        }</span>
        <span class="cov0" title="0">return out</span>
}

//classical robin-round style
//e.g.
//1 2 3 4 5
//5 1 2 3 4
//4 5 1 2 3
//...
func rightRotateLayout(row, col int) [][]int <span class="cov0" title="0">{
        arr2D := make([][]int, row)
        for i := 0; i &lt; row; i++ </span><span class="cov0" title="0">{
                arr2D[i] = make([]int, col)
                for j := 0; j &lt; col; j++ </span><span class="cov0" title="0">{
                        arr2D[i][j] = (j - i + col) % col
                }</span>
        }
        <span class="cov0" title="0">return arr2D</span>
}

func monitorCancel(cancel context.CancelFunc) <span class="cov0" title="0">{
        channel := make(chan os.Signal, 2)
        signal.Notify(channel, syscall.SIGINT, syscall.SIGTERM)
        &lt;-channel
        cancel()
}</span>

func goroutineNum() int <span class="cov0" title="0">{
        return runtime.NumGoroutine()
}</span>

//make an 2D byte slice
func makeArr2DByte(row, col int) [][]byte <span class="cov8" title="1">{
        out := make([][]byte, row)
        for i := range out </span><span class="cov8" title="1">{
                out[i] = make([]byte, col)
        }</span>
        <span class="cov8" title="1">return out</span>
}

//make an 2D int slice
func makeArr2DInt(row, col int) [][]int <span class="cov8" title="1">{
        out := make([][]int, row)
        for i := range out </span><span class="cov8" title="1">{
                out[i] = make([]int, col)
        }</span>
        <span class="cov8" title="1">return out</span>
}

//check if two file are completely same
//warning: use io.copy
func checkFileIfSame(dst, src string) (bool, error) <span class="cov0" title="0">{
        if ok, err := pathExist(dst); err != nil || !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if ok, err := pathExist(src); err != nil || !ok </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">fdst, err := os.Open(dst)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer fdst.Close()
        fsrc, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer fsrc.Close()
        hashDst, err := hashStr(fdst)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">hashSrc, err := hashStr(fsrc)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return hashDst == hashSrc, nil</span>
}

//retain hashstr
func hashStr(f *os.File) (string, error) <span class="cov8" title="1">{
        h := sha256.New()
        if _, err := io.Copy(h, f); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">out := fmt.Sprintf("%x", h.Sum(nil))
        return out, nil</span>
}

//fillRandom
func fillRandom(p []byte) <span class="cov8" title="1">{
        for i := 0; i &lt; len(p); i += 7 </span><span class="cov8" title="1">{
                val := rand.Int()
                for j := 0; i+j &lt; len(p) &amp;&amp; j &lt; 7; j++ </span><span class="cov8" title="1">{
                        p[i+j] = byte(val)
                        val &gt;&gt;= 8
                }</span>
        }
}

//string2Slice
func stringToSlice2D(s string) [][]int <span class="cov0" title="0">{
        s = strings.Trim(s, "[]\n")
        strs := strings.Split(s, ",")
        row := len(strs)
        out := make([][]int, row)
        for i := 0; i &lt; row; i++ </span><span class="cov0" title="0">{
                sub := strings.Trim(strs[i], "[]\n")
                for _, num := range strings.Split(sub, ",") </span><span class="cov0" title="0">{
                        n, _ := strconv.Atoi(num)
                        out[i] = append(out[i], n)
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

//copyfile
func copyFile(srcFile, destFile string) (int64, error) <span class="cov8" title="1">{
        file1, err := os.Open(srcFile)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer file1.Close()
        file2, err := os.OpenFile(destFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer file2.Close()
        return io.Copy(file2, file1)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package grasure

import (
        "fmt"
        "sort"
)

const (
        BASE = iota
        LOAD_BALANCE
        RANDOM
        GREEDY
)

//SGA is a fast-recovery  algorithm that balance the read block amount for each disk
//Currently, only support diskFail mode
//
//output: loadBalancedScheme stripeNum x K array
func (e *Erasure) SGA(fi *fileInfo, gca_enable bool) (loadBalancedScheme [][]int, stripeOrder map[int][]int, err error) <span class="cov0" title="0">{
        //first, make clear how many disks need to be recovered
        //Second, match backup partners
        //Third, concurrently recover the part of the files
        failNodeNum := 0
        failNodeSet := &amp;IntSet{}
        for i := 0; i &lt; e.DiskNum; i++ </span><span class="cov0" title="0">{
                if !e.diskInfos[i].available </span><span class="cov0" title="0">{
                        failNodeSet.Insert(i)
                        failNodeNum++
                }</span>
        }
        <span class="cov0" title="0">if failNodeNum == 0 </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>
        //the failure number exceeds the fault tolerance
        <span class="cov0" title="0">if failNodeNum &gt; e.M </span><span class="cov0" title="0">{
                return nil, nil, errTooFewDisksAlive
        }</span>
        // maxRepairPerSlice := (e.DiskNum - int(failNodeNum)) / e.M
        // if !e.Quiet {
        //         log.Println("The maximum stripes could be repaired in parallel is", sga.maxRepairPerSlice)
        // }
        //failStripeNum is the number of failed stripes
        <span class="cov0" title="0">failStripeNum := 0
        //failStripeSet marks which file has which failed stripe
        failStripeSet := &amp;IntSet{}
        //diskLoads marks the number of blocks for each disk
        diskLoads := make([]int, e.DiskNum)
        //diskLoads records every disk's stripe information
        diskDict := make([]IntSet, e.DiskNum)
        fileSize := fi.FileSize
        stripeNum := int(ceilFracInt64(fileSize, e.dataStripeSize))
        dist := fi.Distribution
        loadBalancedScheme = make([][]int, stripeNum)
        //stripeRedu records how many blocks a failed stripe can reduce
        stripeRedu := make(map[int]int)
        //avlbleSum is the total redundant blocks
        avlbleSum := 0
        for i := 0; i &lt; stripeNum; i++ </span><span class="cov0" title="0">{
                flag := true
                failBlk := 0
                for j := 0; j &lt; e.K+e.M; j++ </span><span class="cov0" title="0">{
                        if failNodeSet.Exist(dist[i][j]) </span><span class="cov0" title="0">{

                                if _, ok := stripeRedu[i]; ok </span><span class="cov0" title="0">{
                                        stripeRedu[i]--
                                }</span> else<span class="cov0" title="0"> {
                                        stripeRedu[i] = e.M - 1
                                }</span>
                                <span class="cov0" title="0">failBlk++
                                flag = false</span>
                        } else<span class="cov0" title="0"> {
                                diskLoads[dist[i][j]]++
                                diskDict[dist[i][j]].Insert(i)
                        }</span>

                }
                <span class="cov0" title="0">if failBlk &gt; 0 </span><span class="cov0" title="0">{
                        avlbleSum += (e.M - failBlk)
                }</span>
                <span class="cov0" title="0">if !flag </span><span class="cov0" title="0">{
                        failStripeNum += 1
                        failStripeSet.Insert(i)

                }</span>
        }
        <span class="cov0" title="0">failStripeVec := []int{}
        for k := range *failStripeSet </span><span class="cov0" title="0">{
                failStripeVec = append(failStripeVec, k)
        }</span>
        <span class="cov0" title="0">sort.Ints(failStripeVec)

        // maxload_idx is the current maximal reducible load's index
        maxload_idx := e.DiskNum - 1
        //failReduList records the disks failing to reduce in maxReduVec
        failReduList := &amp;IntSet{}
        //maxReduVec records the maximal loaded disk set w.r.t stripe
        maxReduVec := &amp;IntSet{}

        last_avlbleSum := 0
        for avlbleSum &gt; 0 </span><span class="cov0" title="0">{
                //we obtain current load set for each disk and sort in descending order
                tempDiskLoad := make([]int, e.DiskNum)
                copy(tempDiskLoad, diskLoads)
                sort.Ints(tempDiskLoad)
                curMaxLoad := tempDiskLoad[maxload_idx]
                maxRedu := 0
                maxReduVec.Clear()
                for i := 0; i &lt; e.DiskNum; i++ </span><span class="cov0" title="0">{
                        if !failNodeSet.Exist(i) &amp;&amp; !failReduList.Exist(i) &amp;&amp; diskLoads[i] == curMaxLoad </span><span class="cov0" title="0">{
                                reduNum := len(diskDict[i])
                                if reduNum &gt; maxRedu </span><span class="cov0" title="0">{
                                        maxReduVec.Clear()
                                        maxReduVec.Insert(i)
                                        maxRedu = reduNum
                                }</span> else<span class="cov0" title="0"> if reduNum == maxRedu </span><span class="cov0" title="0">{
                                        maxReduVec.Insert(i)
                                }</span>
                        }

                }
                <span class="cov0" title="0">if maxReduVec.Empty() </span><span class="cov0" title="0">{
                        maxload_idx--
                        continue</span>
                }
                //if current maximally loaded disk are fully reduced
                //we don't have to judge whether the current maxmimal load is accessible
                <span class="cov0" title="0">isMaxReducible := false
                for j := range *maxReduVec </span><span class="cov0" title="0">{
                        for k := range diskDict[j] </span><span class="cov0" title="0">{
                                if stripeRedu[k] &gt; 0 </span><span class="cov0" title="0">{
                                        avlbleSum--
                                        stripeRedu[k]--
                                        diskDict[j].Erase(k)
                                        diskLoads[j]--
                                        isMaxReducible = true
                                        break</span>
                                }
                                <span class="cov0" title="0">if isMaxReducible </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
                //if current maximally loaded disk are fully reduced
                //He could borrow some money from previously the richest relatives, for illustration
                <span class="cov0" title="0">if !isMaxReducible </span><span class="cov0" title="0">{
                        for j := range *maxReduVec </span><span class="cov0" title="0">{
                                for s := range *failStripeSet </span><span class="cov0" title="0">{
                                        for n := 0; n &lt; e.DiskNum; n++ </span><span class="cov0" title="0">{
                                                if !failReduList.Exist(n) &amp;&amp;
                                                        !failNodeSet.Exist(n) &amp;&amp;
                                                        !diskDict[j].Exist(s) &amp;&amp;
                                                        diskDict[n].Exist(s) &amp;&amp;
                                                        diskLoads[n] == diskLoads[j]-1 </span><span class="cov0" title="0">{

                                                        diskDict[n].Insert(s)
                                                        diskDict[j].Erase(s)
                                                        diskLoads[n]++
                                                        diskLoads[j]--
                                                        isMaxReducible = true
                                                        break</span>
                                                }

                                        }
                                        <span class="cov0" title="0">if isMaxReducible </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if avlbleSum == last_avlbleSum </span><span class="cov0" title="0">{
                                        failReduList.Insert(j)
                                }</span>
                                <span class="cov0" title="0">if isMaxReducible </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">last_avlbleSum = avlbleSum</span>
        }
        //maxLoad calculates the maximal load of disks
        <span class="cov0" title="0">maxLoad := 0
        //sum is the loads of each disk
        sumDisk := make([]int, e.DiskNum)
        //sumLoad is the total load of all disks
        sumLoad := 0
        //mapInd stores disk-to-block_index mapping
        // mapInd := make([]int, e.DiskNum)
        //for every stripe, determine which stripes chosen for recovery
        for s := 0; s &lt; stripeNum; s++ </span><span class="cov0" title="0">{
                if failStripeSet.Exist(s) </span><span class="cov0" title="0">{
                        for i := 0; i &lt; e.K+e.M; i++ </span><span class="cov0" title="0">{
                                if !failNodeSet.Exist(dist[s][i]) &amp;&amp; diskDict[dist[s][i]].Exist(s) </span><span class="cov0" title="0">{
                                        loadBalancedScheme[s] = append(loadBalancedScheme[s], dist[s][i])
                                        sumDisk[dist[s][i]]++
                                        maxLoad = max(maxLoad, sumDisk[dist[s][i]])
                                        sumLoad++
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        loadBalancedScheme[s] = dist[s]
                }</span>
        }
        <span class="cov0" title="0">if !e.Quiet </span><span class="cov0" title="0">{
                fmt.Printf("---------------SGA Algorithm--------------")
                fmt.Printf("\nmaxLoad:%d, sumLoad: %d\n", maxLoad, sumLoad)
                fmt.Printf("disk loads:\n%v\n", sumDisk)
        }</span>
        // if !reflect.DeepEqual(diskLoads, sumDisk) {
        //         return nil, fmt.Errorf("SGA verifying failed")
        // }
        // tmp := make([][]int, failStripeNum)
        // for i, s := range failStripeSet {
        //         tmp[i] = loadBalancedScheme[s]
        //         fmt.Printf("%v\n", loadBalancedScheme[s])
        // }
        <span class="cov0" title="0">if !gca_enable </span><span class="cov0" title="0">{
                return loadBalancedScheme, nil, nil
        }</span>
        <span class="cov0" title="0">graph := make(map[int][]int)
        edgeNum := 0
        for s1 := range *failStripeSet </span><span class="cov0" title="0">{
                for s2 := range *failStripeSet </span><span class="cov0" title="0">{
                        //if two nodes conflicts, then add an edge
                        if s1 &lt; s2 &amp;&amp; isConflict(&amp;loadBalancedScheme[s1], &amp;loadBalancedScheme[s2], failNodeSet) </span><span class="cov0" title="0">{
                                graph[s1] = append(graph[s1], s2)
                                graph[s2] = append(graph[s2], s1)
                                edgeNum++
                        }</span>
                }
        }
        <span class="cov0" title="0">if edgeNum == 0 </span><span class="cov0" title="0">{
                return loadBalancedScheme, nil, nil
        }</span>
        //minTimeSlice is the minimal time slices needed for recovery
        <span class="cov0" title="0">minTimeSlice := 0
        //record records the used color
        record := IntSet{}
        //stripeColor marks the color of each stripe
        stripeColor := make(map[int]int)
        stripeOrder = make(map[int][]int)
        //we use the disk_vec generated from last step
        //to give assistance to coloring sequence
        cur, maxColor := 0, 0
        for s := range *failStripeSet </span><span class="cov0" title="0">{
                if _, ok := stripeColor[s]; !ok </span><span class="cov0" title="0">{
                        cur = s
                        maxColor = 0
                        record.Clear()
                        for _, neig := range graph[cur] </span><span class="cov0" title="0">{
                                record.Insert(stripeColor[neig])
                                maxColor = max(maxColor, stripeColor[neig])
                        }</span>
                        <span class="cov0" title="0">for t := 1; t &lt;= maxColor+1; t++ </span><span class="cov0" title="0">{
                                if !record.Exist(t) </span><span class="cov0" title="0">{
                                        stripeColor[cur] = t
                                        stripeOrder[t] = append(stripeOrder[t], cur)
                                        minTimeSlice = max(minTimeSlice, t)
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return loadBalancedScheme, stripeOrder, nil</span>
}

func isConflict(arr1, arr2 *[]int, failnodeSet *IntSet) bool <span class="cov0" title="0">{
        for _, a := range *arr1 </span><span class="cov0" title="0">{
                if !failnodeSet.Exist(a) </span><span class="cov0" title="0">{
                        for _, b := range *arr2 </span><span class="cov0" title="0">{
                                if !failnodeSet.Exist(b) </span><span class="cov0" title="0">{
                                        if a == b </span><span class="cov0" title="0">{
                                                return true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
